{$ASSERTIONS OFF}

{((((((((((((((((((((((((((((((((((((((O)))))))))))))))))))))))))))))))))))))))}
{                                                                              }
{                             TMotionDetector v2.4                             }
{                       Copyright (c) 2003 Michael Fornengo                     }
{                             All rights reserved.                             }
{                                                                              }
{   home page:     http://www.datastead.com                                    }
{   contact :      contact@datastead.com                                       }
{   support:       support@datastead.com                                       }
{                                                                              }
{((((((((((((((((((((((((((((((((((((((O))))))))))))))))))))))))))))))))))))))))


                     TMotionDetector LICENSE AGREEMENT
                     ===============================
 Copyright
 ---------
 All datastead.com Software components are copyrighted
 by Michael Fornengo (hereafter "author"), and shall remain the
 exclusive property of the author.

 Agreement
 ---------
 By installing this software you agree with:

 - You may not use the source code in this package to create competitive
   software product (in this case a competitive video capture component).

 - You  may not manipulate any binary files included or generated by
   Delphi/C++Builder using the package.

 - You may not distribute source code or registered version to non
   registered people.

 License statement
 -----------------
 This software and any accompanying documentation are protected
 by France copyright law and also by International Treaty provisions.

 Any use of this software in violation of copyright law or the terms
 of this agreement will be prosecuted to the best of the author's ability.

 You are hereby authorized to make archival copies of this software
 for the sole purpose of back-up and protecting your investment from loss.

 Under no circumstances may you copy this software or documentation for the
 purposes of distribution to others. Under no conditions may you remove
 the copyright notices made part of the software or documentation.

 Distribution Rights
 -------------------
 You are granted a non-exclusive, royalty-free right to produce and distribute
 executable binary files (executables, DLLs, etc.) that are built with the
 registered version of the software, unless specifically stated otherwise.

 Restrictions
 ------------
 Without the express prior written consent of the author, you may not distribute
 any of the author's commercial source code, compiled units or documentation
 by any means whatsoever. You may not transfer, lease, lend, copy, modify,
 translate , sublicense, time-share , or electronically transmit or receive
 the software or documentation.

 Upgrade
 -------
 The upgrade version of the software constitutes a single product of the
 author's software that you upgraded. For example, the upgrade and the software
 that you upgraded cannot both be available for use by two different people
 at the same time, without written permission from the author.

 Disclaimer
 ----------
 The Author cannot and does not warrant that any functions contained
 in the Software will meet your requirements, or that its operations
 will be error free. The entire risk as to the Software performance
 or quality, or both, is solely with the user and not the Author.
 You assume responsibility for the selection of the component to
 achieve your intended results, and for the installation, use, and
 results obtained from the Software.

 The Author makes no warranty, either implied or expressed, including
 without limitation any warranty with respect to this Software
 documented here, its quality, performance, or fitness for a particular
 purpose. In no event shall the Author be liable to you for damages,
 whether direct or indirect, incidental, special, or consequential
 arising out the use of or any defect in the Software,  even if the
 Author has been advised of the possibility of such damages, or for
 any claim by any other party.

 All other warranties of any kind, either express or implied,
 including but not limited to the implied warranties of
 merchantability and fitness for a particular purpose, are expressly
 excluded.
}

unit MoDetect;

interface

{$R-}
{$Q-}


uses
  Windows, Messages, SysUtils, Classes, Graphics, Forms, Dialogs, StdCtrls, ComCtrls, ExtCtrls, Menus, Controls;

type
   TOnMotionDetected = procedure (Sender: TObject; GlobalMotionRatio: Double) of object;
   TOnGridOversizesFrame = procedure (Sender: TObject; Width, Height: integer) of object;

   TMotionDetector = class (TComponent)
   private
      FOnGridOversizesFrame: TOnGridOversizesFrame;
      FOnMotionDetected: TOnMotionDetected;
      FOnMotionNotDetected: TNotifyEvent;
      FOnSettingsChanged: TNotifyEvent;
      FOnNewFrameSize: TNotifyEvent;
      Impl: Pointer;

      function  GetGrid: string;
      function  GetRejectDifferentFrameSize: Boolean;
      function  GetReduceVideoNoise: Boolean;
      function  GetCompareBlue: Boolean;
      function  GetCompareGreen: Boolean;
      function  GetCompareMonochrome: Boolean;
      function  GetCompareRed: Boolean;
      function  GetLastFrame: TBitmap;
      function  GetReleaseFrame: boolean;

      procedure SetGrid (Value_: string);
      procedure SetCompareBlue (Value: boolean);
      procedure SetCompareGreen (Value: boolean);
      procedure SetCompareMonochrome (Value: Boolean);
      procedure SetCompareRed (Value: boolean);
      procedure SetReduceVideoNoise (Value: Boolean);
      procedure SetReleaseFrame (Value: boolean);
      procedure SetRejectDifferentFrameSize (Value: Boolean);
      procedure SwitchGrid (Xmouse, Ymouse: integer);

   public

      constructor Create (AOwner: TComponent); override;
      destructor  Destroy; override;

      function  CellMotionRatio (x, y: integer): Double;
      procedure SetGlobalSensitivity (Value: integer);
      procedure ChangeGlobalSensitivity (Increment: integer);
      function  DetectMotion (NewFrame: TBitmap): boolean;
      function  Get2DTextGrid: string;
      function  Get2DTextMotion: string;
      function  GlobalMotionRatio: Double;
      function  GridXCount: integer;
      function  GridYCount: integer;
      function  IsGridValid: Boolean;
      procedure Reset;
      function  SetCellSensitivity (x, y, Value: integer): Boolean;
      function  SetGridSize (x, y: integer): boolean;
      procedure ShowGridDialog;
      property  LastFrame: TBitmap read GetLastFrame;

   published
      property CompareBlue: Boolean read GetCompareBlue write SetCompareBlue;
      property CompareGreen: Boolean read GetCompareGreen write SetCompareGreen;
      property CompareMonochrome: Boolean read GetCompareMonochrome write SetCompareMonochrome;
      property CompareRed: Boolean read GetCompareRed write SetCompareRed;
      property Grid: string read GetGrid write SetGrid;
      property ReduceVideoNoise: Boolean read GetReduceVideoNoise write SetReduceVideoNoise;
      property RejectDifferentFrameSize: Boolean read GetRejectDifferentFrameSize write SetRejectDifferentFrameSize;
      property ReleaseFrame: Boolean read GetReleaseFrame write SetReleaseFrame;

      property OnGridOversizesFrame: TOnGridOversizesFrame read FOnGridOversizesFrame write FOnGridOversizesFrame;
      property OnMotionDetected: TOnMotionDetected read FOnMotionDetected write FOnMotionDetected;
      property OnMotionNotDetected: TNotifyEvent read FOnMotionNotDetected write FOnMotionNotDetected;
      property OnNewFrameSize: TNotifyEvent read FOnNewFrameSize write FOnNewFrameSize;
      property OnSettingsChanged: TNotifyEvent read FOnSettingsChanged write FOnSettingsChanged;
   end;

  TGridDialog = class(TForm)
    Button1: TButton;
    Image1: TImage;
    Edit2: TEdit;
    UpDown1: TUpDown;
    Button2: TButton;
    PopupMenu1: TPopupMenu;
    N11: TMenuItem;
    N21: TMenuItem;
    N31: TMenuItem;
    N41: TMenuItem;
    N51: TMenuItem;
    N61: TMenuItem;
    N71: TMenuItem;
    N81: TMenuItem;
    N91: TMenuItem;
    Button3: TButton;
    Button4: TButton;
    UpDown2: TUpDown;
    Label1: TLabel;
    Label2: TLabel;
    procedure Button1Click(Sender: TObject);
    procedure UpDown1Click(Sender: TObject; Button: TUDBtnType);
    procedure Image1MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure UpdatePopup(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure Button3Click(Sender: TObject);
    procedure Button4Click(Sender: TObject);
    procedure UpDown2Click(Sender: TObject; Button: TUDBtnType);
    procedure Button2Click(Sender: TObject);
  private
     DlgDet: TMotionDetector;
    procedure FindBestCurrentLevel;
  public
     procedure ShowDialog (Det: TMotionDetector);
  end;

  procedure Register;

implementation

const
   DEFAULTLEVEL = 5;
      Bc = 0;
      Gc = 1;
      Rc = 2;

{$R *.DFM}

type
   TBgr = array[0..2] of byte;
   pTBgr = ^TBgr;

   TGrid = record
      Grid_0_9: array of array of integer;
      MotionPixelDetected: array of array of integer;
      MotionPixelTotal: array of array of integer;
      Sensibility_0_256: array of array of integer;
      xStep: array of integer;
      yStep: array of integer;
      xCount, yCount: double;
   end;

   TImpMotionDetector = class
   private
      FCurrentLevel: integer;
      FChangedCompareCriterias: Boolean;
      FCompareBlue: Boolean;
      FCompareGreen: Boolean;
      FCompareMonochrome: Boolean;
      FCompareRed: Boolean;
      FCurrentBitmap, bmOri : TBitmap;
      FGrid: string;
      FGridWidthOversizes: integer;
      FGridHeightOversizes: integer;
      FDetecting: Boolean;
      FInternalGrid: TGrid;
      FIsGridValid: Boolean;
      FMotionRatio: Double;
      FPixelFormat: TPixelFormat;
      FReduceVideoNoise: Boolean;
      FRejectDifferentFrameSize: Boolean;
      FReleaseFrame: Boolean;
      FReset: Boolean;
      FStepsFound: Boolean;
      FGridXBound, FGridYBound: integer;
      FGridXSize, FGridYSize: integer;
      procedure ClearMotionResults;
      procedure FindSteps;
      procedure InitBitmap (extbm: TBitmap);
      procedure DisplayCoefs;
      procedure DisplayGrid (Monochrome: Boolean);
      function  GetStep24Or32: integer;
      procedure ModifyColorsToMonochrome (Bitmap: TBitmap);
      procedure RedrawMatricedBitmap;
      procedure ReduceVideoNoiseImage (SrcBitmap, DestBitmap: TBitmap);
      procedure DoReduceVideoNoiseImage (ExtBm: TBitmap);
      procedure InitGrid (Level: integer);
      function  IsGridValid (Value: string): Boolean;
      procedure RebuildGridFromInternal;
      procedure SetGrid (Value: string);
      function  SetCellCount (ValueX, ValueY: integer): boolean;
      procedure SetInternalGridValue (i, j, Value_0_9: integer);
   end;

//------------------------------------------------------------------------------
constructor TMotionDetector.Create (AOwner: TComponent);
//------------------------------------------------------------------------------
begin
   inherited Create (AOwner);
   Impl := TImpMotionDetector.Create;
   with TImpMotionDetector (Impl) do begin
      SetCellCount (10, 10);
      FDetecting:= False;
      FGridWidthOversizes := 0;
      FGridHeightOversizes := 0;
      FMotionRatio:= 0;
      FCompareBlue := True;
      FCompareGreen := True;
      FCompareMonochrome := False;
      FCompareRed := True;
      FCurrentBitmap := nil;
      FRejectDifferentFrameSize := False;
      FReleaseFrame:= True;
      FReset:= False;
      FStepsFound:= False;
      ClearMotionResults;

      FCurrentBitmap := TBitmap.create;
      FReduceVideoNoise := False;
      FChangedCompareCriterias:= True;
      FCurrentLevel := DEFAULTLEVEL;
      InitGrid (FCurrentLevel);
      FPixelFormat := pfDevice;
   end;
end;

//------------------------------------------------------------------------------
destructor TMotionDetector.Destroy;
//------------------------------------------------------------------------------
begin
   with TImpMotionDetector (Impl) do begin
      if assigned (bmOri) then begin
         if not bmOri.Empty then bmOri.FreeImage;
         BmOri.Free;
      end;
      if not FCurrentBitmap.Empty then FCurrentBitmap.FreeImage;
      FCurrentBitmap.Free;
   end;
   TImpMotionDetector (Impl).Free;
   inherited Destroy;
end;

//------------------------------------------------------------------------------
function TMotionDetector.DetectMotion (NewFrame: TBitmap): boolean;
//------------------------------------------------------------------------------
var
   x,y : Integer;
   pBm1, pBm2: LongWord;
   iX, iY: integer;
   Step24or32: LongWord;
   Threshold: integer;
   NewBitmap: TBitmap;
   MotionPixelsDetected: integer;
   MotionPixelsTotal: integer;
   MotionDetected: Boolean;

begin
 with TImpMotionDetector (Impl) do begin

  Result := False;

  if FDetecting then Exit;
  FDetecting:= True;

  NewBitmap := TBitmap.Create;

  if FReleaseFrame then begin
     NewBitmap.Assign (NewFrame);
  end
  else begin
     NewBitmap.Handle := NewFrame.Handle;
     NewFrame.ReleaseHandle;
  end;

  try

  MotionDetected := False;

   Step24Or32 := GetStep24Or32;

   ClearMotionResults;

   if FReset then begin
      FReset := False;
      InitBitmap (NewBitmap);
      Exit;
   end
   else if (FCurrentBitmap.Width <> NewBitmap.Width)
         or (FCurrentBitmap.Height <> NewBitmap.Height)
         or (FCurrentBitmap.PixelFormat <> NewBitmap.PixelFormat) then begin
      if not FRejectDifferentFrameSize then begin
         InitBitmap (NewBitmap);
      end;
      if assigned (FOnNewFrameSize) then FOnNewFrameSize (Self);
      Exit;
   end;

   if (FGridWidthOversizes <> 0)
    or (FGridHeightOversizes <> 0) then begin
      if assigned (FOnGridOversizesFrame) then FOnGridOversizesFrame (Self, FGridWidthOversizes, FGridHeightOversizes);
   end;

   if FCompareMonochrome then begin
      ModifyColorsToMonochrome (NewBitmap);
   end;

   if FReduceVideoNoise then begin
      DoReduceVideoNoiseImage (NewBitmap);
   end;

   Assert (FStepsFound, '02 step not found');

   iY := 0;
   for y := 0 to FCurrentBitmap.Height - 1 do begin
       if iY < FGridYBound then begin
          if y > FInternalGrid.YStep[iY] then begin
             inc (iY);
          end;
       end;
       PBm1 := LongWord (NewBitmap.ScanLine[y]);
       PBm2 := LongWord (FCurrentBitmap.ScanLine[y]);
       iX := 0;
       for x := 0 to FCurrentBitmap.Width - 1 do begin
           if iX < FGridXBound then begin
              if x > FInternalGrid.XStep[iX] then begin
                 inc (iX);
              end;
           end;

           if FInternalGrid.Grid_0_9[iX, iY] > 0 then begin

              FInternalGrid.MotionPixelTotal[iX, iY] := FInternalGrid.MotionPixelTotal[iX, iY] + 1;

              Threshold := FInternalGrid.Sensibility_0_256[iX, iY];
              if FCompareMonochrome then begin
                 if (abs (pTBgr(pBm1)[Bc] - pTBgr(pBm2)[Bc]) > Threshold) then begin // monochrome, 1 color is sufficient
                    FInternalGrid.MotionPixelDetected[iX, iY] := FInternalGrid.MotionPixelDetected[iX, iY] + 1;
                 end;
              end
              else begin
                 if (FCompareBlue  and (abs (pTBgr(pBm1)[Bc] - pTBgr(pBm2)[Bc]) > Threshold)) or
                    (FCompareGreen and (abs (pTBgr(pBm1)[Gc] - pTBgr(pBm2)[Gc]) > Threshold)) or
                    (FCompareRed   and (abs (pTBgr(pBm1)[Rc] - pTBgr(pBm2)[Rc]) > Threshold)) then begin
                    FInternalGrid.MotionPixelDetected[iX, iY] := FInternalGrid.MotionPixelDetected[iX, iY] + 1;
                 end;
              end;
           end;
           pBm1 := pBm1 + Step24or32;
           pBm2 := pBm2 + Step24or32;
       end;
   end;

   if not FCurrentBitmap.Empty then FCurrentBitmap.FreeImage;
   FCurrentBitmap.Handle := NewBitmap.Handle;
   NewBitmap.ReleaseHandle;

   MotionPixelsDetected := 0;
   MotionPixelsTotal := 0;

   for iY := 0 to FGridYBound do begin
      for iX := 0 to FGridXBound do begin
         if FInternalGrid.MotionPixelTotal[iX, iY] > 0 then begin
            MotionPixelsTotal := MotionPixelsTotal + FInternalGrid.MotionPixelTotal[iX, iY];
            MotionPixelsDetected := MotionPixelsDetected + FInternalGrid.MotionPixelDetected[iX, iY];
         end;
      end;
   end;

   if FChangedCompareCriterias then begin
      FChangedCompareCriterias := False;
      if assigned (FOnSettingsChanged) then FOnSettingsChanged (Self);
   end
   else begin
      if MotionPixelsDetected > 0 then begin
         FMotionRatio:= Round ((MotionPixelsDetected / MotionPixelsTotal * 10000)) / 10000;
         MotionDetected := True;
         if assigned (FOnMotionDetected) then FOnMotionDetected (Self, FMotionRatio);
      end
      else begin
         if assigned (FOnMotionNotDetected) then FOnMotionNotDetected (Self);
      end;
   end;

   if not MotionDetected then begin
      ClearMotionResults;
   end;

   Result := MotionDetected;

  finally
   if not NewBitmap.Empty then NewBitmap.FreeImage;
   NewBitmap.Free;
   FDetecting := False;
  end;
 end;
end;

//------------------------------------------------------------------------------
function TMotionDetector.GetLastFrame: TBitmap;
//------------------------------------------------------------------------------
begin
   with TImpMotionDetector (Impl) do begin
      Result := FCurrentBitmap;
   end;
end;

//------------------------------------------------------------------------------
function TMotionDetector.Get2DTextGrid: string;
//------------------------------------------------------------------------------
// this function builds a 2D text representation of the grid sensitivity
//------------------------------------------------------------------------------
var
   i, j: integer;
   sl: TStringList;
   Temp: string;
   Temp2: string;
begin
 with TImpMotionDetector (Impl) do begin
   sl := TStringList.Create;
   for i := 0 to FGridYBound do begin
      Temp := Copy (Grid, (i * (FGridXSize + 1)) + 1, FGridXSize);
      Temp2 := '';
      for j := 1 to length (Temp) do begin
         if Temp[j] = '0' then begin
            Temp2 := Temp2 + '. ';
         end
         else begin
            Temp2 := Temp2 + Temp[j] + ' ';
         end;
      end;
      sl.Add (Trim (Temp2));
   end;
   Result := sl.Text;
   sl.Free;
 end;
end;

//------------------------------------------------------------------------------
function TMotionDetector.Get2DTextMotion: string;
//------------------------------------------------------------------------------
// this function builds a 2D text represention of the motion detected within the grid
//------------------------------------------------------------------------------
var
   i, j: integer;
   sl: TStringList;
   Temp2: string;
   Det: integer;
   MotionRatio: Double;
begin
 with TImpMotionDetector (Impl) do begin
   sl := TStringList.Create;
   sl.text := '';
   for i := 0 to FGridYBound do begin
      Temp2 := '';
      for j := 0 to FGridXBound do begin
         MotionRatio := CellMotionRatio (j, i);
         if MotionRatio > 0 then begin
            Det := Round (MotionRatio * 10);
            if Det > 9 then begin
               Det := 9;
            end;
            Temp2 := Temp2 + Char (Det + 48) + ' ';
         end
         else begin
            Temp2 := Temp2 + '. ';
         end;
      end;
      sl.Add (Temp2);
   end;
   Result := sl.Text;
   sl.Free;
 end;
end;

//------------------------------------------------------------------------------
function TMotionDetector.IsGridValid: Boolean;
//------------------------------------------------------------------------------
begin
   Result := TImpMotionDetector (Impl).FIsGridValid;
end;

//------------------------------------------------------------------------------
function TMotionDetector.GetGrid: string;
//------------------------------------------------------------------------------
begin
   Result := TImpMotionDetector (Impl).FGrid;
end;

//------------------------------------------------------------------------------
function TMotionDetector.GridXCount: integer;
//------------------------------------------------------------------------------
begin
   Result := TImpMotionDetector (Impl).FGridXSize;
end;

//------------------------------------------------------------------------------
function TMotionDetector.GridYCount: integer;
//------------------------------------------------------------------------------
begin
   Result := TImpMotionDetector (Impl).FGridYSize;
end;

//------------------------------------------------------------------------------
function TMotionDetector.CellMotionRatio (x, y: integer): Double;
//------------------------------------------------------------------------------
begin
 with TImpMotionDetector (Impl) do begin
   Result := -1;
   if x < 0 then Exit;
   if x > FGridXBound then Exit;
   if y < 0 then Exit;
   if y > FGridYBound then Exit;
   if FInternalGrid.MotionPixelDetected[x, y] > 0 then begin
      Result := Round ((FInternalGrid.MotionPixelDetected[x, y] / FInternalGrid.MotionPixelTotal[x, y] * 10000)) / 10000;
   end
   else begin
      Result := 0;
   end;
 end;
end;

//------------------------------------------------------------------------------
function TMotionDetector.SetCellSensitivity (x, y, Value: integer): Boolean;
//------------------------------------------------------------------------------
begin
 with TImpMotionDetector (Impl) do begin
   Result := False;
   if x < 0 then Exit;
   if x > FGridXBound then Exit;
   if y < 0 then Exit;
   if y > FGridYBound then Exit;
   if Value < 0 then Exit;
   if Value > 9 then Exit;
   FInternalGrid.Grid_0_9[x, y] := Value;
   RebuildGridFromInternal;
   Result := True;
 end;
end;

//------------------------------------------------------------------------------
function  TMotionDetector.GlobalMotionRatio: Double;
//------------------------------------------------------------------------------
begin
   Result := TImpMotionDetector (Impl).FMotionRatio;
end;

//------------------------------------------------------------------------------
procedure TMotionDetector.ShowGridDialog;
//------------------------------------------------------------------------------
var
  GridDialog: TGridDialog;
begin
   GridDialog := TGridDialog.Create (nil);
   GridDialog.ShowDialog (Self);
   GridDialog.Free;
end;

//------------------------------------------------------------------------------
procedure TImpMotionDetector.InitGrid (Level: integer);
//------------------------------------------------------------------------------
var
   i, j: integer;
   Mx: string;
begin
   Mx := '';
   for i := 0 to FGridYBound do begin
      for j := 0 to FGridXBound do begin
         Mx := Mx + Char (Level + 48);
      end;
      Mx := Mx + ' ';
   end;
   SetGrid (Mx);
end;

//------------------------------------------------------------------------------
procedure TMotionDetector.ChangeGlobalSensitivity (Increment: integer);
//------------------------------------------------------------------------------
var
   i, j: integer;
   Current: integer;
begin
 with TImpMotionDetector (Impl) do begin
   for i := 0 to FGridXBound do begin
      for j := 0 to FGridYBound do begin
         Current := FInternalGrid.Grid_0_9[i,j];
         if (Current > 0) and (((Increment < 0) and  (Current > 1)) or ((Increment > 0) and (Current < 9))) then begin
            Current := Current  + Increment;
            if Current < 0 then begin
               Current := 0;
            end;
            if Current > 9 then begin
               Current := 0;
            end;
            SetInternalGridValue (i, j, Current);
         end;
      end;
   end;
   RebuildGridFromInternal;
 end;
end;

//------------------------------------------------------------------------------
procedure TMotionDetector.SetGlobalSensitivity (Value: integer);
//------------------------------------------------------------------------------
var
   i, j: integer;
begin
   if (Value >= 0) and (Value <= 9) then begin
      with TImpMotionDetector (Impl) do begin
         for i := 0 to FGridXBound do begin
            for j := 0 to FGridYBound do begin
               SetInternalGridValue (i, j, Value);
            end;
         end;
         RebuildGridFromInternal;
      end;
   end;
end;

//------------------------------------------------------------------------------
procedure TMotionDetector.SetGrid (Value_: string);
//------------------------------------------------------------------------------
begin
   TImpMotionDetector (Impl).SetGrid (Value_);
end;

//------------------------------------------------------------------------------
function TMotionDetector.SetGridSize (x, y: integer): boolean;
//------------------------------------------------------------------------------
begin
   result := TImpMotionDetector (Impl).SetCellCount (x, y);
end;

//------------------------------------------------------------------------------
procedure TMotionDetector.Reset;
//------------------------------------------------------------------------------
begin
   TImpMotionDetector (Impl).FReset := True;
end;

//------------------------------------------------------------------------------
function TMotionDetector.GetCompareBlue: Boolean;
//------------------------------------------------------------------------------
begin
   Result := TImpMotionDetector(Impl).FCompareBlue;
end;

//------------------------------------------------------------------------------
function TMotionDetector.GetCompareGreen: Boolean;
//------------------------------------------------------------------------------
begin
   Result := TImpMotionDetector(Impl).FCompareGreen;
end;

//------------------------------------------------------------------------------
function TMotionDetector.GetCompareMonochrome: Boolean;
//------------------------------------------------------------------------------
begin
   Result := TImpMotionDetector(Impl).FCompareMonochrome;
end;

//------------------------------------------------------------------------------
function TMotionDetector.GetCompareRed: Boolean;
//------------------------------------------------------------------------------
begin
   Result := TImpMotionDetector(Impl).FCompareRed;
end;

//------------------------------------------------------------------------------
function TMotionDetector.GetRejectDifferentFrameSize: Boolean;
//------------------------------------------------------------------------------
begin
   Result := TImpMotionDetector(Impl).FRejectDifferentFrameSize;
end;

//------------------------------------------------------------------------------
procedure TMotionDetector.SetRejectDifferentFrameSize (Value: Boolean);
//-----------------------------------------------------------------------------
begin
   TImpMotionDetector(Impl).FRejectDifferentFrameSize := Value;
end;

//------------------------------------------------------------------------------
function TMotionDetector.GetReduceVideoNoise: Boolean;
//------------------------------------------------------------------------------
begin
   Result := TImpMotionDetector (Impl).FReduceVideoNoise;
end;

//------------------------------------------------------------------------------
procedure TMotionDetector.SwitchGrid (Xmouse, Ymouse: integer);
//------------------------------------------------------------------------------
var
   x, y: integer;
   xFound, yFound: integer;
   Done: Boolean;
begin
 with TImpMotionDetector (Impl) do begin

   Assert (FStepsFound, '03 steps not found');

   xFound := -1;
   x := 0;
   Done := False;
   while not Done do begin
      if x > FGridXBound then begin
         Done := True;
      end
      else begin
         if xMouse < FInternalGrid.xStep[x] then begin
            xFound := x;
            Done := True;
         end;
         inc (x);
      end;
   end;
   yFound := -1;
   y := 0;
   Done := False;
   while not Done do begin
      if y > FGridYBound then begin
         Done := True;
      end
      else begin
         if Ymouse < FInternalGrid.yStep[y] then begin
            yFound := y;
            Done := True;
         end;
         inc (y);
      end;
   end;
   if (xFound <> -1) and (yFound <> -1) then begin
      if FInternalGrid.Grid_0_9[xFound, yFound] <> 0 then begin
         FInternalGrid.Grid_0_9[xFound, yFound] := 0;
      end
      else begin
         FInternalGrid.Grid_0_9[xFound, yFound] := FCurrentLevel;
      end;
      RedrawMatricedBitmap;
   end;
 end;
end;

//------------------------------------------------------------------------------
procedure TMotionDetector.SetCompareBlue (Value: Boolean);
//------------------------------------------------------------------------------
begin
 with TImpMotionDetector (Impl) do begin
   if Value = FCompareBlue then Exit;
   FCompareBlue := Value;
 end;
end;

//------------------------------------------------------------------------------
procedure TMotionDetector.SetCompareGreen (Value: Boolean);
//------------------------------------------------------------------------------
begin
 with TImpMotionDetector (Impl) do begin
   if Value = FCompareGreen then Exit;
   FCompareGreen := Value;
 end;
end;

//------------------------------------------------------------------------------
procedure TMotionDetector.SetCompareMonochrome (Value: Boolean);
//------------------------------------------------------------------------------
begin
 with TImpMotionDetector (Impl) do begin
   if Value = FCompareMonochrome then Exit;
   FCompareMonochrome := Value;
   FChangedCompareCriterias := True;
 end;
end;

//------------------------------------------------------------------------------
procedure TMotionDetector.SetCompareRed (Value: Boolean);
//------------------------------------------------------------------------------
begin
 with TImpMotionDetector (Impl) do begin
   if Value = FCompareRed then Exit;
   FCompareRed := Value;
 end;
end;

//------------------------------------------------------------------------------
procedure TMotionDetector.SetReduceVideoNoise (Value: Boolean);
//------------------------------------------------------------------------------
begin
 with TImpMotionDetector (Impl) do begin
   if Value = FReduceVideoNoise then Exit;
   FReduceVideoNoise := Value;
   FChangedCompareCriterias := True;
 end;
end;

//------------------------------------------------------------------------------
function TMotionDetector.GetReleaseFrame: boolean;
//------------------------------------------------------------------------------
begin
   Result := TImpMotionDetector (Impl).FReleaseFrame;
end;

//------------------------------------------------------------------------------
procedure TMotionDetector.SetReleaseFrame (Value: boolean);
//------------------------------------------------------------------------------
begin
   with TImpMotionDetector (Impl) do begin
      if Value = FReleaseFrame then Exit;
      FReleaseFrame := Value;
   end;
end;

//------------------------------------------------------------------------------
procedure TImpMotionDetector.SetInternalGridValue (i, j, Value_0_9: integer);
//------------------------------------------------------------------------------
begin
   FInternalGrid.Grid_0_9[i, j] := Value_0_9;
   FInternalGrid.Sensibility_0_256[i, j] := 256 - ((Value_0_9 * 56) shr 1); // = 256 - n * 28,4
end;

//------------------------------------------------------------------------------
function TImpMotionDetector.IsGridValid (Value: string): Boolean;
//------------------------------------------------------------------------------
var
   GridStringLen: integer;
   m: integer;
   i, j: integer;
   GridValid: Boolean;
begin
   GridStringLen := (FGridXSize * FGridYSize) + FGridYSize - 1; // 109 for 10
   Value := Trim (Copy (Value, 1, GridStringLen));

   GridValid := False;

   if length (Value) = GridStringLen then begin
      GridValid := True;
      m := 1;
      for j := 0 to FGridYBound do begin
         for i := 0 to FGridXBound do begin
            if (Value[m] < '0') or (Value[m] > '9') then begin
               GridValid := False;
            end;
            inc (m);
         end;
         if j < FGridYBound then begin
            if Value[m] <> ' ' then begin
               GridValid := False;
            end;
         end;
         inc (m);
      end;
   end;
   Result := GridValid;
end;

//------------------------------------------------------------------------------
procedure TImpMotionDetector.SetGrid (Value: string);
//------------------------------------------------------------------------------
var
   i, j: integer;
   Value_0_9: integer;
   m: integer;
begin
   FIsGridValid := IsGridValid (Value);

   if Value = FGrid then Exit;

   if not FIsGridValid then Exit;

   FGrid := Value;

   m := 1;
   for j := 0 to FGridYBound do begin
      for i := 0 to FGridXBound do begin
         Value_0_9 := ord(Value[m]) - 48;
         SetInternalGridValue (i, j, Value_0_9);
         inc (m);
      end;
      inc (m);
   end;
end;

//------------------------------------------------------------------------------
function TImpMotionDetector.SetCellCount (ValueX, ValueY: integer): boolean;
//------------------------------------------------------------------------------
begin
   Result := False;

   if (ValueX < 1) or (ValueY < 1) then begin
      Exit;
   end;

   Result := True;

   if (FGridXSize = ValueX) and (FGridYSize = ValueY) then Exit;

   FGridXSize := ValueX;
   FGridYSize := ValueY;

   FGridXBound := ValueX - 1;
   FGridYBound := ValueY - 1;

   with FInternalGrid do begin
      Grid_0_9:= nil;
      MotionPixelDetected:= nil;
      MotionPixelTotal:= nil;
      Sensibility_0_256:= nil;
      xStep:= nil;
      yStep:= nil;
      SetLength (Grid_0_9, FGridXSize, FGridYSize);
      SetLength (MotionPixelDetected, FGridXSize, FGridYSize);
      SetLength (MotionPixelTotal, FGridXSize, FGridYSize);
      SetLength (Sensibility_0_256, FGridXSize, FGridYSize);
      SetLength (xStep, FGridXSize);
      SetLength (yStep, FGridYSize);
   end;
   InitGrid (FCurrentLevel);
   if assigned (FCurrentBitmap) then begin
      FindSteps;
   end;
   FChangedCompareCriterias := True;
end;

//------------------------------------------------------------------------------
procedure TImpMotionDetector.RebuildGridFromInternal;
//------------------------------------------------------------------------------
var
   i, j: integer;
begin
   FGrid := '';
   for j := 0 to FGridYBound do begin
      for i := 0 to FGridXBound do begin
          FGrid := FGrid + Char (FInternalGrid.Grid_0_9[i, j] + 48);
      end;
      if j < FGridYBound then begin
         FGrid := FGrid + ' ';
      end;
   end;
   FIsGridValid := True;
end;

//------------------------------------------------------------------------------
procedure TImpMotionDetector.InitBitmap (extbm: TBitmap);
//------------------------------------------------------------------------------
begin
   FCurrentBitmap.Assign (extbm);
   FPixelFormat := FCurrentBitmap.PixelFormat;
   if FPixelFormat < pf24bit then begin
      FCurrentBitmap.PixelFormat := pf24bit;
      FPixelFormat := pf24bit;
   end;
   if FCompareMonochrome then begin
      ModifyColorsToMonochrome (FCurrentBitmap);
   end;
   if FReduceVideoNoise then begin
      DoReduceVideoNoiseImage (ExtBm);
   end;
   FindSteps;
end;

//------------------------------------------------------------------------------
function  TImpMotionDetector.GetStep24Or32: integer;
//------------------------------------------------------------------------------
begin
   if FPixelFormat = pf24bit then begin
      Result := 3;
   end
   else begin
      Result := 4;
   end;
end;

//------------------------------------------------------------------------------
procedure TImpMotionDetector.DisplayGrid (Monochrome: Boolean);
//------------------------------------------------------------------------------
var
   x,y : Integer;
   PDest, pOri: LongWord;
   iX, iY: integer;
   Step24or32: LongWord;
begin
   Assert (FStepsFound, '04 step not found');

   Step24Or32 := GetStep24Or32;

   if not assigned (bmOri) then begin
      bmOri := TBitmap.create;
      bmOri.Assign (FCurrentBitmap);
   end;

   iY := 0;
   for y := 0 to FCurrentBitmap.height - 1 do begin
      if (y = FInternalGrid.YStep[iY]) and (iY < FGridYBound) then begin
         FCurrentBitmap.Canvas.MoveTo (0, y);
         FCurrentBitmap.Canvas.LineTo (FCurrentBitmap.Width, y);
      end
      else begin
        if y > FInternalGrid.YStep[iY] then begin
           inc (iY);
        end;
        PDest := LongWord (FCurrentBitmap.ScanLine[y]);
        POri := LongWord (bmOri.ScanLine[y]);
        iX := 0;
        for x := 0 to FCurrentBitmap.width -1 do begin
           if iX < FGridXBound then begin
              if x = FInternalGrid.XStep[iX] then begin
                 FCurrentBitmap.Canvas.MoveTo (x, 0);
                 FCurrentBitmap.Canvas.LineTo (x, FCurrentBitmap.Height);
              end
              else begin
                 if x > FInternalGrid.XStep[iX] then begin
                    inc (iX);
                 end;
              end;
           end;
           if FInternalGrid.Grid_0_9[iX, iY] > 0 then begin
              pTBgr(pDest)[Gc] := 255 - pTBgr(pOri)[Gc];
              pTBgr(pDest)[Rc] := 255 - pTBgr(pOri)[Rc];
              pTBgr(pDest)[Bc] := 255 - pTBgr(pOri)[Bc];
           end
           else begin
              pTBgr(pDest)[Bc] := pTBgr(pOri)[Bc];
              pTBgr(pDest)[Gc] := pTBgr(pOri)[Gc];
              pTBgr(pDest)[Rc] := pTBgr(pOri)[Rc];
           end;
           inc (pDest, step24or32);
           inc (pOri, step24or32);
        end;
      end;
   end;
end;

//------------------------------------------------------------------------------
procedure TImpMotionDetector.FindSteps;
//------------------------------------------------------------------------------
var
   x, y: integer;
begin
   FStepsFound := False;
   if FCurrentBitmap.Width = 0 then Exit;
   if FCurrentBitmap.Height = 0 then Exit;

   FGridWidthOversizes := 0;
   FGridHeightOversizes := 0;

   if FGridXSize > FCurrentBitmap.Width then begin
      FGridWidthOversizes := FGridXSize - FCurrentBitmap.Width;
   end;
   if FGridYSize > FCurrentBitmap.Height then begin
      FGridHeightOversizes := FGridYSize - FCurrentBitmap.Height;
   end;

   FInternalGrid.xCount := FCurrentBitmap.Width / FGridXSize;
   FInternalGrid.yCount := FCurrentBitmap.Height / FGridYSize;
   for x := 0 to FGridXSize - 2 do begin
      FInternalGrid.xStep[x] := Round (FInternalGrid.xCount * (x+1));
   end;
   FInternalGrid.xStep[FGridXSize - 1] := MAXINT;

   for y := 0 to FGridYSize - 2 do begin
      FInternalGrid.yStep[y] := Round (FInternalGrid.yCount * (y+1));
   end;
   FInternalGrid.yStep[FGridYSize - 1] := MAXINT;

   FStepsFound := True;
end;

//------------------------------------------------------------------------------
procedure BmTextParams (xWidth, yHeight: Double; var FontSize, xShift, yShift: integer);
//------------------------------------------------------------------------------
var
   xCenter, yCenter: Double;
begin
   xCenter := xWidth / 2;
   yCenter := yHeight / 2;
   if xWidth < 20 then begin
      FontSize := 7;
      xCenter := xCenter - 2;
      yCenter := yCenter - 5;
   end
   else if xWidth < 30 then begin
      FontSize := 8;
      xCenter := xCenter - 3;
      yCenter := yCenter - 8;
   end
   else if xWidth < 40 then begin
      FontSize := 10;
      xCenter := xCenter - 4;
      yCenter := yCenter - 8;
   end
   else begin
      FontSize := 12;
      xCenter := xCenter - 4;
      yCenter := yCenter - 8;
   end;
   if xCenter < 0 then begin
      xCenter := 1;
   end;
   if yCenter < 0 then begin
      yCenter := 1;
   end;
   xShift := Round (xCenter);
   yShift := Round (yCenter);
end;

//------------------------------------------------------------------------------
procedure TImpMotionDetector.DisplayCoefs;
//------------------------------------------------------------------------------
var
   x, y: integer;
   xShift, yShift: integer;
   FontSize: integer;
begin
   FCurrentBitmap.Canvas.Font.Name := 'Courier New';
   FCurrentBitmap.Canvas.Brush.Color := clDkGray;
   FCurrentBitmap.Canvas.Font.Color := clWhite;
   BmTextParams (FInternalGrid.xCount, FInternalGrid.yCount, FontSize, xShift, yShift);
   FCurrentBitmap.Canvas.Font.Size  := FontSize;
   for x := 0 to FGridXBound do begin
       for y := 0 to FGridYBound do begin
          FCurrentBitmap.Canvas.TextOut (Round (x * FInternalGrid.xCount) + xShift, Round (y * FInternalGrid.yCount) + yShift, inttostr (FInternalGrid.Grid_0_9[x, y]));
       end;
   end;
end;

//------------------------------------------------------------------------------
procedure TImpMotionDetector.RedrawMatricedBitmap;
//------------------------------------------------------------------------------
begin
   DisplayGrid (false);
   DisplayCoefs;
end;

//------------------------------------------------------------------------------
procedure TImpMotionDetector.DoReduceVideoNoiseImage (ExtBm: TBitmap);
//------------------------------------------------------------------------------
var
   Tmp: TBitmap;
begin
   Tmp := TBitmap.Create;
   Tmp.Assign (extbm);
   ReduceVideoNoiseImage (Tmp, ExtBm);
   if not Tmp.Empty then Tmp.FreeImage;
   Tmp.Free;
end;

//------------------------------------------------------------------------------
procedure TImpMotionDetector.ReduceVideoNoiseImage (SrcBitmap, DestBitmap: TBitmap);
//------------------------------------------------------------------------------
var
   x,y : Integer;

   pS_Prev, pS_Curr, pS_Next: LongWord;
   pD_Prev, pD_Curr, pD_Next: LongWord;

   Step24or32: LongWord;
   iMax: integer;
begin
   Step24Or32 := GetStep24Or32;

   if SrcBitmap.Height < 3 then Exit;
   if SrcBitmap.Width < 3 then Exit;

   pS_Curr := 0;
   pS_Next := 0;
   pD_Curr := 0;

   for y := 0 to SrcBitmap.Height - 1 do begin

      pS_Prev := LongWord (SrcBitmap.ScanLine[y]);
      pD_Prev := LongWord (DestBitmap.ScanLine[y]);

      iMax := SrcBitmap.Width - 4;

      for x := 0 to iMax do begin

         pS_Curr := pS_Prev + Step24or32;
         pS_Next := pS_Curr + Step24or32;

         if x = 0 then begin
            pTBgr(pD_Prev)[Bc] := Round ((pTBgr(pS_Prev)[Bc] + pTBgr(pS_Curr)[Bc]) / 3);
            pTBgr(pD_Prev)[Gc] := Round ((pTBgr(pS_Prev)[Gc] + pTBgr(pS_Curr)[Gc]) / 3);
            pTBgr(pD_Prev)[Rc] := Round ((pTBgr(pS_Prev)[Rc] + pTBgr(pS_Curr)[Rc]) / 3);
         end;

         pD_Curr := pD_Prev + Step24or32;

         pTBgr(pD_Curr)[Bc] := Round ((pTBgr(pS_Prev)[Bc] + pTBgr(pS_Curr)[Bc] + pTBgr(pS_Next)[Bc]) / 3);
         pTBgr(pD_Curr)[Gc] := Round ((pTBgr(pS_Prev)[Gc] + pTBgr(pS_Curr)[Gc] + pTBgr(pS_Next)[Gc]) / 3);
         pTBgr(pD_Curr)[Rc] := Round ((pTBgr(pS_Prev)[Rc] + pTBgr(pS_Curr)[Rc] + pTBgr(pS_Next)[Rc]) / 3);

         pS_Prev := pS_Curr;
         pD_Prev := pD_Curr;
      end;

      // last pD_Next for x = iMax
      pD_Next := pD_Curr + Step24or32;
      pTBgr(pD_Next)[Bc] := Round ((pTBgr(pS_Next)[Bc] + pTBgr(pS_Curr)[Bc]) / 3);
      pTBgr(pD_Next)[Gc] := Round ((pTBgr(pS_Next)[Gc] + pTBgr(pS_Curr)[Gc]) / 3);
      pTBgr(pD_Next)[Rc] := Round ((pTBgr(pS_Next)[Rc] + pTBgr(pS_Curr)[Rc]) / 3);
   end;

   iMax := SrcBitmap.Height - 4;
   for y := 0 to iMax do begin

      pS_Prev := LongWord (SrcBitmap.ScanLine[y]);
      pS_Curr := LongWord (SrcBitmap.ScanLine[y + 1]);
      pS_Next := LongWord (SrcBitmap.ScanLine[y + 2]);

      pD_Prev := LongWord (DestBitmap.ScanLine[y]);
      pD_Curr := LongWord (DestBitmap.ScanLine[y + 1]);
      pD_Next := LongWord (DestBitmap.ScanLine[y + 2]);

      for x := 0 to SrcBitmap.Width - 1 do begin

         pTBgr(pD_Curr)[Bc] := Round ((pTBgr(pS_Prev)[Bc] + pTBgr(pS_Curr)[Bc] + pTBgr(pS_Next)[Bc]) / 3);
         pTBgr(pD_Curr)[Gc] := Round ((pTBgr(pS_Prev)[Gc] + pTBgr(pS_Curr)[Gc] + pTBgr(pS_Next)[Gc]) / 3);
         pTBgr(pD_Curr)[Rc] := Round ((pTBgr(pS_Prev)[Rc] + pTBgr(pS_Curr)[Rc] + pTBgr(pS_Next)[Rc]) / 3);

         if y = 0 then begin
            pTBgr(pD_Prev)[Bc] := Round ((pTBgr(pS_Prev)[Bc] + pTBgr(pS_Curr)[Bc]) / 3);
            pTBgr(pD_Prev)[Gc] := Round ((pTBgr(pS_Prev)[Gc] + pTBgr(pS_Curr)[Gc]) / 3);
            pTBgr(pD_Prev)[Rc] := Round ((pTBgr(pS_Prev)[Rc] + pTBgr(pS_Curr)[Rc]) / 3);
         end
         else if y = iMax then begin
            pTBgr(pD_Next)[Bc] := Round ((pTBgr(pS_Next)[Bc] + pTBgr(pS_Curr)[Bc]) / 3);
            pTBgr(pD_Next)[Gc] := Round ((pTBgr(pS_Next)[Gc] + pTBgr(pS_Curr)[Gc]) / 3);
            pTBgr(pD_Next)[Rc] := Round ((pTBgr(pS_Next)[Rc] + pTBgr(pS_Curr)[Rc]) / 3);
         end;

         pS_Prev := pS_Prev + Step24or32;
         pS_Curr := pS_Curr + Step24or32;
         pS_Next := pS_Next + Step24or32;

         pD_Prev := pD_Prev + Step24or32;
         pD_Curr := pD_Curr + Step24or32;
         pD_Next := pD_Next + Step24or32;
      end;
   end;
end;

//------------------------------------------------------------------------------
procedure TImpMotionDetector.ModifyColorsToMonochrome (Bitmap: TBitmap);
//------------------------------------------------------------------------------
var
   x,y : Integer;
   pBm1: LongWord;
   Grey: Byte;
   Step24or32: LongWord;
begin
   Step24Or32 := GetStep24Or32;
   for y := 0 to FCurrentBitmap.Height - 1 do begin
      PBm1 := LongWord (Bitmap.ScanLine[y]);
      for x := 0 to FCurrentBitmap.Width - 1 do begin
         Grey := Trunc ((pTBgr(pBm1)[Bc] + pTBgr(pBm1)[Gc] + pTBgr(pBm1)[Rc]) / 3);
         pTBgr(pBm1)[Bc] := Grey;
         pTBgr(pBm1)[Gc] := Grey;
         pTBgr(pBm1)[Rc] := Grey;
         inc (pBm1, Step24or32);
      end;
   end;
end;

//------------------------------------------------------------------------------
procedure TImpMotionDetector.ClearMotionResults;
//------------------------------------------------------------------------------
var
   i, j: integer;
begin
   FMotionRatio:= 0;
   for j := 0 to FGridYBound do begin
      for i := 0 to FGridXBound do begin
         FInternalGrid.MotionPixelDetected[i, j] := 0;
         FInternalGrid.MotionPixelTotal[i, j] := 0;
      end;
   end;
end;

//------------------------------------------------------------------------------
procedure TGridDialog.Button1Click(Sender: TObject);
//------------------------------------------------------------------------------
begin
   Button1.Tag := 1;
   Close;
end;

//------------------------------------------------------------------------------
procedure TGridDialog.UpDown1Click(Sender: TObject; Button: TUDBtnType);
//------------------------------------------------------------------------------
begin
   TImpMotionDetector (DlgDet.Impl).FCurrentLevel := UpDown1.Position;
   PopupMenu1.Items[TImpMotionDetector (DlgDet.Impl).FCurrentLevel - 1].Checked := True;
end;

//------------------------------------------------------------------------------
procedure TGridDialog.FindBestCurrentLevel;
//------------------------------------------------------------------------------
var
   n: integer;
   Sum: integer;
   x, y: integer;
begin
 with TImpMotionDetector (DlgDet.Impl) do begin
   n := 0;
   Sum := 0;
   for x := 0 to FGridXBound do begin
      for y := 0 to FGridYBound do begin
         if FInternalGrid.Grid_0_9[x, y] <> 0 then begin
            inc (Sum, FInternalGrid.Grid_0_9[x, y]);
            inc (n);
         end;
      end;
   end;
   if n > 0 then begin
      FCurrentLevel := Round (Sum / n);
   end
   else begin
      FCurrentLevel := DEFAULTLEVEL;
   end;
 end;
end;

//------------------------------------------------------------------------------
procedure TGridDialog.ShowDialog (Det: TMotionDetector);
//------------------------------------------------------------------------------
var
   CurrBm: TBitmap;
begin
   CurrBm := TBitmap.Create;

   if (TImpMotionDetector (Det.Impl).FCurrentBitmap.Width <> 0) and (TImpMotionDetector (Det.Impl).FCurrentBitmap.Height <> 0) then begin
      CurrBm.Width := Image1.Width;
      CurrBm.Height := Round ((Image1.Width * TImpMotionDetector (Det.Impl).FCurrentBitmap.height) / TImpMotionDetector (Det.Impl).FCurrentBitmap.Width);
      Image1.Height := CurrBm.Height;
      CurrBm.Canvas.StretchDraw (Rect (0, 0, CurrBm.Width, CurrBm.Height), TImpMotionDetector (Det.Impl).FCurrentBitmap);
   end
   else begin
      CurrBm.Width := Image1.Width;
      CurrBm.Height := Image1.Height;
      CurrBm.Canvas.FillRect (Rect (0, 0, Image1.Width, Image1.Height));
   end;

   DlgDet.SetGridSize (Det.GridXCount, Det.GridYCount);
   DlgDet.Grid := Det.Grid;
   TImpMotionDetector (DlgDet.Impl).InitBitmap (CurrBm);
   TImpMotionDetector (DlgDet.Impl).RedrawMatricedBitmap;
   CurrBm.FreeImage;
   CurrBm.Free;
   Image1.Picture.Assign (TImpMotionDetector (DlgDet.Impl).FCurrentBitmap);
   Application.ProcessMessages;
   FindBestCurrentLevel;
   UpDown1.Position := TImpMotionDetector (DlgDet.Impl).FCurrentLevel;
   PopupMenu1.Items[TImpMotionDetector (DlgDet.Impl).FCurrentLevel - 1].Checked := True;
   ShowModal;
   if Button1.Tag = 1 then begin
      TImpMotionDetector (DlgDet.Impl).RebuildGridFromInternal;
      Det.Grid := DlgDet.Grid;
   end;
end;

//------------------------------------------------------------------------------
procedure TGridDialog.Image1MouseDown(Sender: TObject; Button: TMouseButton;
//------------------------------------------------------------------------------
  Shift: TShiftState; X, Y: Integer);
begin
   if Button = mbLeft then begin
      if not assigned (DlgDet) then Exit;
      DlgDet.SwitchGrid (X, Y);
      Image1.Canvas.draw(0,0,TImpMotionDetector (DlgDet.Impl).FCurrentBitmap);
   end
   else if Button = mbRight then begin
      PopupMenu1.Popup (Mouse.CursorPos.x, Mouse.CursorPos.y);
   end;
end;

//------------------------------------------------------------------------------
procedure TGridDialog.UpdatePopup(Sender: TObject);
//------------------------------------------------------------------------------
begin
   Case TMenuItem(Sender).Tag of
      1: N11.Checked := True;
      2: N21.Checked := True;
      3: N31.Checked := True;
      4: N41.Checked := True;
      5: N51.Checked := True;
      6: N61.Checked := True;
      7: N71.Checked := True;
      8: N81.Checked := True;
      9: N91.Checked := True;
   end;
   TImpMotionDetector (DlgDet.Impl).FCurrentLevel := TMenuItem(Sender).Tag;
   UpDown1.Position := TImpMotionDetector (DlgDet.Impl).FCurrentLevel;
end;

//------------------------------------------------------------------------------
procedure TGridDialog.FormCreate(Sender: TObject);
//------------------------------------------------------------------------------
begin
   DlgDet := TMotionDetector.Create (Self);
   DlgDet.ReduceVideoNoise := False;
end;

//------------------------------------------------------------------------------
procedure TGridDialog.Button3Click(Sender: TObject);
//------------------------------------------------------------------------------
begin
 with TImpMotionDetector (DlgDet.Impl) do begin
   InitGrid (0);
   RedrawMatricedBitmap;
   Image1.Canvas.draw(0,0,FCurrentBitmap);
 end;
end;

//------------------------------------------------------------------------------
procedure TGridDialog.Button4Click(Sender: TObject);
//------------------------------------------------------------------------------
begin
 with TImpMotionDetector (DlgDet.Impl) do begin
   InitGrid (FCurrentLevel);
   RedrawMatricedBitmap;
   Image1.Canvas.draw(0,0,FCurrentBitmap);
 end;
end;

//------------------------------------------------------------------------------
procedure TGridDialog.UpDown2Click(Sender: TObject; Button: TUDBtnType);
//------------------------------------------------------------------------------
var
   Increment: integer;
begin
 with TImpMotionDetector (DlgDet.Impl) do begin
   if Button = btNext then begin
      Increment := 1;
   end
   else begin
      Increment := -1;
   end;
   DlgDet.ChangeGlobalSensitivity (Increment);
   RedrawMatricedBitmap;
   Image1.Canvas.draw(0,0,FCurrentBitmap);
 end;
end;

//------------------------------------------------------------------------------
procedure TGridDialog.Button2Click(Sender: TObject);
//------------------------------------------------------------------------------
begin
   Button1.Tag := 0;
   Close;
end;

//------------------------------------------------------------------------------
procedure Register;
//------------------------------------------------------------------------------
begin
  RegisterComponents('DataStead', [TMotionDetector]);
end;

end.
